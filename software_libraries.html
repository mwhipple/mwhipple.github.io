<html>
  <head>
    <title>Software Libraries - Matt Whipple</title>
  </head>

  <body>
    <h1>Software Libraries</h1>
    
    <p>
      <a href="https://github.com/dtolnay/anyhow"
	 title="GitHub - dtolnay/anyhow: Flexible concrete Error type built on std::error::Error"
	 data-atime="2024-04-13">anyhow</a> seems fairly heavily used throughout Rust projects.
      It was one of the first libraries I came across while starting to work with Rust in earnest
      (through working on gstreamer). The code is nice and clean with well-documented key files,
      and the project overall seems like a nice demonstration of how to implement a compatibility
      layer in Rust. For narrow uses it seems as though making use of the standard Error trait
      may be sufficient, but this certainly seems like a valuable tool for building maintainable,
      portable software which is likely a core aspect of the Rust
      model when compared to providing or expecting a broad standard library (which is something I'd
      want to find or write a description of at some point).
    </p>
    <p>
      <a href="https://github.com/purcell/exec-path-from-shell"
	 title="GitHub - purcell/exec-path-from-shell: Make Emacs use the $PATH set up by the user's shell"
	 data-atime="2024-04-29">exec-path-from-shell</a> is a fairly
	 widely used module to make sure that values from interactive
	 shells are available to Emacs on OS X and elsewhere. The
	 logic is a fairly straightforward invocation and parsing of
	 an interactive shell. The code itself is small with most of
	 it being in support of adapting around use so this can act as
	 a readily usable module rather than more of a code library
	 (which could be reduced to a few small functions).
    </p>
    <p>
      <a href="https://github.com/jpverkamp/bit-struct"
	 title="GitHub - jpverkamp/bit-struct: Binary structs for
		Racket with conversion to/from bytes"
	 data-atime="2024-04-24">bit-struct</a> is a library I quickly
      skimmed through while looking at options for C-style
      bitfields in Scheme. It provides a range of macros to provide
      this type of functionality but I ultimately landed on the
      opinion that composed logic for serialization/deserialization
      would be far simpler.
    </p>
    <p>
      <a href="https://github.com/chyh1990/yaml-rust"
	 title="GitHub - chyh1990/yaml-rust: A pure rust YAML implementation."
	 data-atime="2024-04-23">yaml-rust</a> provides YAML parsing
      and emitting in a form that at least seems worth
      repurposing. The most up-to-date YAML logic for Rust seems
      potentially elusive, or this project is just old as it has
      remained good enough. The code is a fairly specialized state
      machine type flow with a split between lexing/scanning and
      parsing. I'll be looking to build on this as part of thoughts
      around application programming, but may also look at
      generalizing some of the behavior a bit (and also looking for
      a more grammar-y alternative.
    </p>
  </body>
</html>

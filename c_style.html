<html>

<p>
One of the most pressing concerns when writing C is around error handling.
Not only does the language not provide much in the way of dealing with errors
and many of the older standard mechanism not play well with mutli-threading
and reentrance, but since the language itself is somewhat hosted with minimal
assumptions about its runtime there are many more possible errors that written
code needs to account for that may otherwise be absorbed by a runtime
(for example when dealing with dynamic memory).
</p><p>
In order to rein in the range of such errors
<a href="panic">panics</a> will be used in the form of assertions.
In Fluent C this is named the "Samurai Principle" but per
<a href="https://wiki.c2.com/?SamuraiPrinciple"
   title="Samurai Principle"
   data-date="2024-02-20">WikiWikiWeb</a>
it may not be entirely appropriate depending on how it is applied.
</p><p>
In particular this will be used in two cases - where the runtime is
considered to be a state which is both unexpected and from which
there is also no expected graceful recovery (such as a failure
when interacting with dynamic memory). This will also be used
in some cases where the preconditions of a documented contract
has been violated by client code (and should therefore not happen
at runtime in a properly implemented system). The latter case is where
the definition of the Samurai Principle seems to be stretched in that
it is the calling code that has dishonored itself through the
contract violation rather than the code that is panicking.
In other languages there may be more elegant mechanisms to model
such guarantees, but in C this seems likely to tip past the point
of diminishing returns and deviate from language idioms.
</p>

</html>

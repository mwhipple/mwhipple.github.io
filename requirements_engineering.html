<html>
  <head>
    <title>Input Events - Matt Whipple</title>
  </head>
  <body>
    <h1>Input Events</h1>
    
    <p>
      <ul>
	<li>a OOOOR 04</li>
	<li>b OOLOM 05</li>
	<li>c OMROO 06</li>
	<li>d OMOOR 07</li>
	<li>e OOMOO 08</li>
	<li>f OMORO 09</li>
	<li>g OOROR 0A</li>
	<li>h OOOOM 0B</li>
	<li>i OOROO 0C</li>
	<li>j OMMRO 0D</li>
	<li>k OORMM 0E</li>
	<li>l OMOMO 0F</li>
	<li>m OMOOM 10</li>
	<li>n OOORO 11</li>
      o OOLOO
      p OOMOM
      q OMMLO
      r OOOLO
      s OOOOL
      t OOOMO
	u OMOLO
	v OOMOR
	w OLOOM
	x OOOLM
	y OOROM
	z OOLMM
      </ul>
    </p>
  </body>
</html>
<html>
  <head>
    <title>Requirements Engineering - Matt Whipple</title>
  </head>

  <body>
    <nav>
      <ul>
	<li><a href="index">Home</a></li>
      </ul>
    </nav>
    <article>
      <h1>Requirements Engineering</h1>

      <p>
	Requirements engineering is a discipline which seems to be
	fairly neglected in many software organizations and likely
	culturally across software engineering. It seems as though
	unfortunately <a href="agile">Agile</a> is too often
	interpreted in a way that fosters disregarding of
	requirements, though User Requirements in particular offer a
	clear means to record and validate the value delivery which is
	the core tenet of Agile. This seems to be very much the case
	in my limited experience, as systems without clear
	requirements tend to be increasingly designed in terms of
	themselves over time, and correspondingly drift further from
	value which can be validated independently and weighed against
	possible forms of waste. A far healthier route in my opinion
	is for some level of requirements engineering to be a core
	part of software engineering, providing a framework within
	which both the system and its surrounding context can be
	understood and refined.
      </p>

      <p>
	My introduction to the practice (at least the one that stuck)
	was attending
	<a href="https://learning.acm.org/techtalks/PEGS"
	   title="The Four PEGS of Requirements Engineering with
		  Bertrand Meyer"
	   data-atime="2024-05-17">Bertrand Meyer's ACM Talk on
	  PEGS</a>.
	There are unfortunately some pretty disruptive audio issues for a fair
	amount of the talk. I've recently started to draw on the PEGS
	model as it provides helpful categorization, somewhat distinct
	terms (trying to evangelize the difference between User
	Requirements and System Requirements can feel pedantic whereas
	"Goals" feels a bit more expressive), and the relationships
	allow for tracking everything back to the environment if
	the process is extended to include identifying those
	under-served needs that drive the value proposition
	(I'm not sure if Bertrand's approach includes that, I should
	pick up the corresponding book if its available now).
      </p>

<!--
From a verification perspective lack of requirements is also very problematic. I've worked for several
companies that adopted a stance that the current behavior of the system is the way that it should behave
but such a perpsective is incredibly limiting in that a system that is specified in terms of itself cannot
be safely changed...or perhaps more accurately _any_ change is putatively safe since any newly introduced
issues would just be blindly incorporated into the imaginary specification. Such a perspective makes larger
scale changes virtually impossible, as are managing concerns such as forward and backward compatibility and
avoiding lockstep deployments. Not surprisingly those companies that had this perpsective were also mired
in states in which changes were difficult and dangerous and complexity and bloat accreted unchecked.
Typically in such organizations I end up starting the long-haul of retroactively building out executable
specifications.
</p><p>
One of my most frequently referenced resources for requirements engineering is
<a href="http://www.cse.msu.edu/~chengb/RE-491/Papers/dark-corners-re-zave-jackson.pdf"
   title="Four Dark Corners of Requirements Engineering"
   data-date="2024-02-15">Four Dark Corners of Requirements Engineering</a>.
On the most basic level this is a useful reference to dissuade implementation bias which
seems fairly endemic particularly when engineers specify their systems, and provides a helpful
perspective in terms of machine and environment which speaks to the underlying desire to be able to
validate rather than just verify. This also provides additional tools in terms of delineating formal
definitions and informal designations and using the latter to trace things back to impacts on the
environment (along with other approaches to track how things fit together). While formal definitions
are unlikely to be palatable in most organizations, having a precise glossary/ubiquitous language is
massive enabler for shared understanding and the assorted approaches to both delineate and connect
the environment and machine through language are very useful to preserve the ability to validate
systems.
</p>

-->
    </article>
  </body>
</html>

<p>
Professionally I work with a variety of technologies...personally I tend to be
drawn to relatively low-level technologies with the goal of deeply understanding
the pieces involved.
</p><p>
On a related note I'm also nursing a perspective around some of the residual
harm caused by attention given to programming languages rather than abstractions
which will be elaborated upon further, but one of the actionable takeaways is
seeking a stripped down means to more portably enable such abstractions.
</p><p>
The above goals on current systems leads pretty naturally to C as it is the
language in which the majority of operating system and systems code is written.
In K&R C is described as somewhat of portable assembly which I think is useful
insofar as it is relatively straightforward to conceive how code written in C
could alternatively be written in assembly - not that this corresponds to the
object code that is likely to be produced by the compiler but there is a fairly
natural mapping of primitives while insulating a developer from needing to
dig through instruction set documentation, expend keystrokes and brain space
shuffling bits to and from registers, and deal translate between a routine
operating on multiple values and the distinct instructions needing to line those
values up.
</p><p>
C certainly has its drawbacks. A path I've followed in the past drew me initially
to C to be closer to the metal - to thinking that C is perfectly reasonable if it
is accompanied by a set of practices and conventions to fill some of its possible
gaps in terms of safety and productivity - to realizing that such practices and
conventions would be best delivered in the form of a new language. In my estimation
therefore C is a nice systems programming language but one of the best first uses
for it is to produce another language.
</p><p>
There are other appealing alternatives, particularly in the interest of safety.
I've dabbled in C++ over the years, and it
is particularly enticing within the mindset of pursuing abstractions over languages
as it is a massive, unopinionated system and therefore speaks to a goal of reducing
the focus on the "language" of how things are expressed and instead emphasizing a
shared means to leverage abstractions. I believe Leslie Lamport has a similar sentiment
floating around to the effect that mathematics would be ideal but pragmatically
everyone should just use C++. Rust is also a language that I'm particularly drawn to,
providing an arguably cleaner alternative than C++ and most of the adopted designs
align very much with my sensibilities. For the time being however, both of these are
being deferred in that the lifting of the compiler expands substantially with either
of them. Hopefully I'll revisit them as I continue on this journey and potentially
adopt subsets (and likely make use of them for work), but I'll be planning on picking
through the compiler I'm using and that will take far longer for full support of
either of those languages. Those two in particular are identified because they
promise fairly natural alignment with the POSIX ABI and C code, other languages
(such as Go) introduce additional runtime considerations which do not match as
directly with some of my goals.
</p><p>
As a result at the moment I'm spending a bit of time doing a deep-dive into
C programming and for now some of the materials will be catalogged here.
</p>
<p>
<a href="https://www.pearson.com/en-us/subject-catalog/p/programming-in-c/P200000000380/9780132781190"
   title="Programming in C"
   data-date="2024-01-23">Programming in C, Fourth Edition</a>
is a good introductory text - it is likely to be most appropriate for relatively
inexperienced programmers for whom C is one of the first languages they are learning.
It builds on the concepts in a way that should provide a solid foundation, but more
experienced developers (at least from my perspective) are likely to find it slow and
lacking in deeper insight (which is a natural consequence of targeting a different
audience). It could use an update to cover some of the newer standards, but is a good
text from which to learn the language - likely the best of those I've read so far.
</p>

#+TITLE: My Emacs Configuration

I use my Emacs configuration both as a means to customize it and to
document standard behavior. As a result much of it will strictly
unnecessary.

I'll also be looking to build up the configuration incrementally along
with supporting knowledge and will start with integrating desired
functionality directly into this file rather than pulling in external
packages. This ties in with an overall goal I have in software in
general to make consistent reuse of abstractions, and also can
hopefully address a concern I've had with Emacs in particular in the
past where it felt as though there was both too much code floating
around the ecosystem and too little readily composable functionality.

I'm currently using ~^-~ as a prefix for my local definitions.
This is inherited from a past project where I started to create a lot
of macros and since the "macs" in Emacs is for macros I was thinking
of it as macros squared...so ~^-~ is in the spirit of that while also
being nice and short.

Over time I'll likely also look to evolve the configuration so that it
is increasingly declarative data structures operated upon by fewer
functions. This may ease reuse of the same configuration across
multiple targets as the number of operations to support will be reduced.

** Define Header

Define some standard header boilerplate like copyright...
most significantly define lexical binding.

#+BEGIN_SRC emacs-lisp :tangle init.el

  ;;; init.el -- Configure emacs to my liking. -*- lexical-binding: t; -*-

  ;; Copyright (C) 2023 Matt Whipple <mattwhipple@acm.org>

  ;; Author: Matt Whipple <mattwhipple@acm.org>
  ;; Maintainer: Matt Whiple <mattwhipple@acm.org>
  ;; Keywords: config
  ;; Package: ^-config
  ;; Package-Version: NA
  ;; Package-Requires: ((emacs "29.1") (dash "2.19.1")
  ;; Filename: init.el

  ;; This file is not part of GNU Emacs.

  ;; This is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This software is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this file.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; This file will collect my configuration and documentation of emacs behavior,
  ;; along with being the initial location of any extensions on which I work.

  ;;; Code:

#+END_SRC

** Check Preconditions

I'll be making use of whatever seems readily available rather than
carefully tracking what features are available on what systems, but as
the lack of certain capabilities translate into errors on some system
or other I'll add tests with more helpful messages here. If any of
this code ends up being split out into libraries this should be
handled with more discipline (and compatibility options should be
explored).

*** JSON Support

This is required for EAF stuff and seems generally useful.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (unless (fboundp #'json-parse-buffer)
    (warn "Emacs does not have JSON support!"))
#+END_SRC

** Configure Startup

#+BEGIN_SRC elisp :tangle init.el
(setq inhibit-startup-screen t)
#+END_SRC

** Configure Package Management

I'm currently ideally being cautious about pulling in packages due to
the more ambitious goal of building out a more unified platform, but
some packages will be embraced and others will be used out of
pragmatism (particularly for professional work).

Here I'll configure some of the standard repositories.

#+BEGIN_SRC emacs-lisp :tangle init.el

  (require 'package)
  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
			   ("melpa" . "https://melpa.org/packages/")))

#+END_SRC

** Enable Desktop Preservation

Use desktop mode to save and restore desktops across invocations.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (desktop-save-mode)
#+END_SRC

** Customize Styling
*** Show Some Stuff

I often have Emacs running full-screen so it's nice if it just provides
me info that I need in the status bar such as what time it is and how
much time until my battery will die and maybe other things that aren't
time related.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (display-battery-mode)
  (display-time-mode)
  (setq display-time-day-and-date t)
#+END_SRC

*** Hide Some Stuff

Currently I'm very keyboard oriented and don't want to waste previous
screen real estate so I'd rather get rid of user interface elements
intended for other forms of interaction. I may revisit this as I look
at using Emacs across a wider range of devices.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (tool-bar-mode -1)
  (menu-bar-mode -1)
#+END_SRC

*** Go Dark

I (like many people) generally prefer themes with dark
backgrounds. Emacs in particular looks particularly primitive with the
default white GUI background whereas on black it looks at least a bit
more retro. While I may be tempted at some point to fiddle with this a
bit more (especially given that it comes with some disclaimers) I'll
start with some code I stumbled upon within the Emacs code base (I
think frame.el...I should link it when I come across it again).

#+BEGIN_SRC emacs-lisp :tangle init.el
  (define-minor-mode dark-mode
    "Use light text on dark background."  
    :global t
    :group 'faces
    (when (eq dark-mode
	      (eq 'light (frame--current-background-mode (selected-frame))))
      ;; FIXME: Change the face's SPEC instead?
      (set-face-attribute 'default nil
			  :foreground (face-attribute 'default :background)
			  :background (face-attribute 'default :foreground))
     (frame-set-background-mode (selected-frame))))
  (dark-mode)
#+END_SRC

*** Tweak Mode Line

I don't remember what this setting does specifically, but I had it
sitting around in an old configuration and figured it was worth
pulling in to figure out later.

#+BEGIN_SRC emacs-lisp tangle: init.el

  (setq-default
    mode-line-format
    (list "%b L%l %p " mode-line-misc-info))

#+END_SRC

** Define Self Inserting Characters

Define and bind chose keys that result in the associated character
being inserted. This is particularly standard behavior as provided by
the terminal though Emacs does add some custom logic. These are
defined in a variable for subsequent specialization (there is likely a
more idiomatic way to do that such as using remap but I haven't gotten
that far yet.

This makes use of the relatively new ~keymap-set~ function which
replaces ~define-key~. Elsewhere will primarily use the `bind-key`
family of macros but this make more direct use of the core
functionality as it lends itself more readily to composition (and
there's no clear value in using anything fancier). I'd generally be on
the fence about using ~bind-key~ but since it's now included in Emacs
it's hard to resist. I'm fairly likely to switch that out later in
favor of something simpler like ~define-keymap~ as I build out my Emacs knowledge.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq self-insert-keys
	'(
	  "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m"			   
	  "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M"
	  "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"
	  "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
	  "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "." "-" "$"
	  "SPC" "=" "_" "*" "\"" "'" "`" "+" "~" "?"
	  "!" "@" "#" "%" "^" "&" "|" "," ";" ":"
	  "(" ")" "{" "}" "[" "]" "<" ">" "/" "\\"
	  ))
  (dolist (k self-insert-keys)
    (apply #'keymap-set (list global-map k #'self-insert-command)))
#+END_SRC

** Bind Some Low-Level Commands

Define some functions that seem relatively fundamental to dealing with
commands and emacs in general.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :map global-map
	     ("C-g" . keyboard-quit)
	     ("M-x" . execute-extended-command)
	     ("M-:" . eval-expression)
	     ("C-x C-c" . save-buffers-kill-terminal)
	     ("C-z" . suspend-frame))
  (setq read-extended-command-predicate nil)
#+END_SRC

** Provide Some Basic Editing
*** Insert Content

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :map global-map
	     ("C-q" . quoted-insert)
	     ("C-x 8 <RET>" . insert-char)
	     ("RET" . newline)
	     ("C-j" . electric-newline-and-maybe-indent)
	     ("TAB" . indent-for-tab-command)
	     ("C-o" . open-line))
#+END_SRC

**** Enable Insertion Using Hex Codes

I don't use this much, but since I'm on a modern system rather than a
DEC or whatever popularized octal I want to use hex when I do.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq read-quoted-char-radix 16)
#+END_SRC
 
*** Remove Content

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("DEL"  . backward-delete-char-untabify)
	     ("M-<DEL>" . backward-kill-word)
	     ;; Chrome OS support
	     ("<deletechar>" . backward-kill-word)
	     ("C-x <DEL>" . backward-kill-sentence)
	     ("M-k" . kill-sentence)
	     ("C-d" .  delete-char)
	     ("C-w" . kill-region)
	     ("M-d" . kill-word)
	     ("C-k" . kill-line)
	     ("C-M-k" . kill-sexp)
	     ("C-S-<backspace>" . kill-whole-line)
	     ("M-^" . delete-indentation)
	     ("M-\\" . cycle-spacing)
	     ;; This needs a new binding.
	     ("C-x C-o" . delete-blank-lines)
	     ("M-z" . zap-up-to-char))
  (setq kill-whole-line nil)
  ;; Preserve dupes for yanking.
  (setq kill-do-not-save-duplicates nil)

#+END_SRC

** Support Moving Point Around Within a Buffer

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("C-f" . forward-char)
	     ("<RIGHT>" . right-char)
	     ("C-b" . backward-char)
	     ("<LEFT>" . left-char)
	     ("C-n" . next-line)
	     ("<DOWN>" . next-line)
	     ("C-p" . previous-line)
	     ("<UP>" . previous-line)
	     ("C-a" . move-beginning-of-line)
	     ("<Home>" . move-beginning-of-line)
	     ("C-e" . move-end-of-line)
	     ("<End>" . move-end-of-line)
	     ("M-f" . forward-word)
	     ("M-<RIGHT>" . right-word)
	     ("M-b" . backward-word)
	     ("M-<LEFT>" . left-word)
	     ("M-r" . move-to-window-line-top-bottom)
	     ("M-n" . forward-list)
	     ("M-p" . backward-list)
	     ("M->" . end-of-buffer)
	     ("M-<" . beginning-of-buffer)
	     ("M-}" . forward-paragraph)
	     ("M-{" . backward-paragraph)
	     ("C-v" . scroll-up-command)
	     ("<PageDown>" . scroll-up-command)
	     ("M-v" . scroll-down-command)
	     ("<PageUp>" . scroll-down-command)
	     ("M-g c" . goto-char)
	     ("M-g <TAB>" . move-to-column)
	     ("M-g g" . goto-line)
	     ("C-x C-n" . set-goal-column)
	     ("C-x <" . scroll-left)
	     ("C-x >" . scroll-right))

#+END_SRC

** Display Information About Buffer Contents

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("M-=" . count-words-region)
	     ("C-x = " . what-cursor-position))
  (setq what-cursor-show-names t)

#+END_SRC

** Change View of Buffer

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :map global-map
	     ("C-l" . recenter-top-bottom)
	     ("C-M-l" .reposition-window)
	     ("C-M-S-l" . recenter-other-window))
#+END_SRC

** Narrowing

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :prefix "C-x n"
	     :prefix-map narrow-map
	     ("d" . narrow-to-defun)
	     ("n" . narrow-to-region)
	     ("p" . narrow-to-page)
	     ("w" . widen))
#+END_SRC

** Play With Mark and the Region

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :map global-map
	     ("C-SPC" . set-mark-command)
	     ("C-@" . set-mark-command)
	     ("M-@" . mark-word)
	     ("M-h" . mark-paragraph)
	     ("C-M-h" . mark-defun)
	     ("C-M-@" . mark-sexp)
	     ("C-x C-p" . mark-page)
	     ("C-x h" . mark-whole-buffer)
	     ("C-x C-<SPC>" . pop-global-mark)
	     ("C-x C-x" . exchange-point-and-mark))

  (setq highlight-nonselected-windows nil)
#+END_SRC

** Work with Kill Ring and History

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("C-/" . undo)
	     ("C-_" . undo)
	     ("C-y" . yank)
	     ("M-y" . yank-pop)
	     ("C-M-w" . append-next-kill)
	     ("M-w" . kill-ring-save))
#+END_SRC

** Work With Rectangles

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :prefix "C-x C-r"
	     :prefix-map rectangle-map
	     ("c" . clear-rectangle)
	     ("d" . delete-rectangle)
	     ("k" . kill-rectangle)
	     ("i" . string-insert-rectangle)
	     ("m" . rectangle-mark-mode)
	     ("N" . rectangle-number-lines)
	     ("o" . open-rectangle)
	     ("r" . copy-rectangle-to-register)
	     ("t" . string-rectangle)
	     ("y" . yank-rectangle)
	     ("\\" . delete-whitespace-rectangle)
	     ("M-w" . copy-rectangle-as-kill))
#+END_SRC

** Provide Some Contextual Editing

While much editing is fairly indifferent to the underlying content,
some may vary behavior slightly based on its context. This does not
extend to include more sophisticated behaviors that require deeper
knowledge of syntactical elements.

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("M-u" . upcase-word)
	     ("M-;" . comment-dwim))

#+END_SRC

** Generate Content

#+BEGIN_SRC emacs-lisp :tangle init.el

    (bind-keys :map global-map
	       ("M-/" . dabbrev-expand)
	       ("M-SPC" . complete-symbol))

#+END_SRC

** Searching and Potentially Replacing

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("C-s" . isearch-forward)
	     ("C-r" . isearch-backward)
	     ("M-%" . query-replace)
	     ("M-." . xref-find-definitions))
  (setq isearch-resume-in-command-history t)
#+END_SRC

** Repeat Commands

and maybe some macro/automation later...

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("C-x z" . repeat)
	     ("C-x <ESC> <ESC>" . repeat-complex-command))
#+END_SRC

** Support Some Inter-Process Communication
*** Support Invoking of External Commands

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys :map global-map
	     ("M-!" . shell-command))
#+END_SRC

** Provide Some Global Dispatching

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :prefix "C-x C-z"
	     :prefix-map dispatch-map
	     ("a" . org-agenda)
	     ("g" . gnus)
	     ("m" . gnus-summary-mail-other-window)
	     ("s" . shell)
	     ("v" . view-mode)
	     ("w" . eww))

#+END_SRC

*** Handle Escape Sequences from External Commands

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
#+END_SRC

** Manage View Objects

Deal with buffers and windows. I'm currently lumping these together
and customizing their binding a bit to make use of the `C-M`
modifier combination. This is an experimental shift, but in a past
adoption of Emacs I remember doing something or other to rebind window
resizing such that it did not require a chain and as these operations
are so fundamental this seems like a potentially nice route.

These are global and since the prefix is likely used elsewhere they
are forced using `bind-keys*` to stick them in the override map.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (bind-keys* ("C-M-n" . next-buffer)
	      ("C-M-<right>" . next-buffer)
	      ("C-M-p" . previous-buffer)
	      ("C-M-<left>" . previous-buffer)
	      ("C-M-b" . switch-to-buffer)
	      ("C-M-k" . kill-buffer)
	      ("C-M-l" . list-buffers)
	      ("C-M-s" . save-buffer)
	      ("C-M-0" . delete-window)
	      ("C-M-1" . delete-other-windows)
	      ("C-M-2" . split-window-below)
	      ("C-M-3" . split-window-right)
	      ("C-M-o" . other-window)
	      ("C-M-}" . enlarge-window-horizontally)
	      ("C-M-{" . shrink-window-horizontally)
	      ("C-M-]" . enlarge-window)
	      ("C-M-[" . shrink-window))
#+END_SRC

** Help Me!

#+BEGIN_SRC emacs-lisp :tangle init.el

	      (bind-keys :prefix "C-h"
			 :prefix-map help-map
			 :prefix-docstring "Help me!"
			 ("a" . apropos-command)
			 ("b" . describe-bindings)
			 ("c" . describe-key-briefly)
			 ("C" . describe-coding-system)
			 ("d" . apropos-documentation)
			 ("e" . view-echo-area-messages)
			 ("f" . describe-function)
			 ("F" . Info-goto-emacs-command-node)
			 ("g" . describe-gnu-project)
			 ("h" . help-for-help)
			 ("H" . view-hello-file)
			 ("i" . info)
			 ("I" . describe-input-method)
			 ("k" . describe-key)
			 ("K" . Info-goto-emacs-key-ommand-node)
			 ("l" . view-lossage)
			 ("L" . describe-language-environment)
			 ("m" . describe-mode)
			 ("n" . view-emacs-news)
			 ("o" . describe-symbol)
			 ("p" . finder-by-keyword)
			 ("P" . describe-package)
			 ("r" . info-emacs-manual)
			 ("s" . describe-syntax)
			 ("S" . Info-lookup-symbol)
			 ("t" . help-with-tutorial)
			 ("v" . describe-variable)
			 ("w" . where-is)
			 ("x" . describe-command)
			 ("." . display-local-help)
			 ("C-c" . describe-copying)
			 ("C-d" . view-emacs-debugging)
			 ("C-e" . view-external-packages)
			 ("C-f" . view-emacs-FAQ)
			 ("C-m" . view-order-manuals)
			 ("C-n" . view-emacs-news)
			 ("C-o" . describe-distribution)
			 ("C-p" . view-emacs-problems)
			 ("C-t" . view-emacs-todo)
			 ("C-w" . describe-no-warranty))

	      (bind-keys :map help-mode-map
			 ("<RET>" . help-follow)
			 ("<TAB>" . forward-button)
			 ("S-<TAB>" . backward-button)
			 ("C-c C-c" . help-follow-symbol)
			 ("C-c C-f" . help-go-forward)
			 ("C-c C-b" . help-go-back)
			 ("s" . help-view-source)
			 ("r" . help-goto-info)
			 ("c" . help-customize))

#+END_SRC

** Bookmark and Register Management

Bookmarks are a feature I'm not actively using at the moment but this
configuration has been carried forward from previous configuration.

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :prefix "C-x C-b"
	     :prefix-map bookmark-map
	     ("b" . bookmark-jump)
	     ("f" . frameset-to-register)
	     ("i" . insert-register)
	     ("j" . jump-to-register)
	     ("l" . list-bookmarks)
	     ("m" . bookmark-set)
	     ("M" . bookmark-set-no-overwrite)
	     ("n" . number-to-register)
	     ("s" . copy-to-register)
	     ("w" . window-configuration-to-register)
	     ("+" . increment-register)
	     ("<SPC>" . point-to-register))
  (setq bookmark-save-flag 1)

#+END_SRC

** Define Some Minibuffer Bindings

#+BEGIN_SRC emacs-lisp :tangle init.el
      (bind-keys :map minibuffer-mode-map
		 ("<TAB>" . minibuffer-complete)
		 ("<SPC>" . minibuffer-complete-word)
		 ("<RET>" . minibuffer-complete-and-exit)
		 ("?" . minibuffer-completion-help)
		 ("M-v" . switch-to-completions)
		 ("M-n" . next-history-element)
		 ("M-p" . previous-history-element)
		 ("<UP>" . previous-line-or-history-element)
		 ("<DOWN>" . next-line-or-history-element)
		 ("M-r" . previous-matching-history-element)
		 ("M-s" . next-matching-history-element))
      (minibuffer-electric-default-mode)
      (setq history-delete-duplicates t)
      (setq resize-mini-windows t)

#+END_SRC

** Completion List Mode

#+BEGIN_SRC emacs-lisp :tangle init.el

	  (bind-keys :map completion-list-mode-map
		     ("<RET>" . choose-completion)
		     ("mouse-1" . choose-completion)
		     ("<TAB>" . next-completion)
		     ("<S-TAB>" . previous-completion)
		     ("q" . quit-window)
		     ("z" . kill-current-buffer))


#+END_SRC

** Define Some Navigation Through a Project

#+BEGIN_SRC emacs-lisp :tangle init.el

  (bind-keys :map global-map
	     ("C-x C-f" . find-file)
	     ("C-x `" . next-error))

#+END_SRC

** Interact With Source Control

Initially this section is just going to contain some bindings that I
copied from a previous incarnation of my Emacs configuration.

#+BEGIN_SRC emacs-lisp :Tangle init.el

      (bind-keys :map global-map
		 ("C-x v v" . vc-next-action)
		 ("C-x v d" . vc-dir))

      (use-package vc
	:bind (:map vc-dir-mode-map
		    ("M-m" . vc-dir-mark)
		    ("M-u" . vc-dir-unmark)
		    ("M-=" . vc-diff)))

#+END_SRC

** Configure Some Shared Behaviors

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq-default require-final-newline t)
#+END_SRC

** Configure Org Mode

#+BEGIN_SRC emacs-lisp :tangle init.el
      (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))

       (use-package org
	 :bind
	 (:prefix "C-x C-o"
	  :prefix-map global-org-map
	  :prefix-docstring "Globally used org mode keys"
	  ("a" . org-agenda)
	  ("c" . org-capture)
	  ("C-<SPC>" . org-store-link))

	 (:map org-mode-map
	 ("DEL" . org-delete-backward-char)
	 ("TAB" . org-cycle)
	 ("C-M-_"    . org-cycle)
	 ("M-RET" . org-meta-return)
	 ("M-<right>" . org-metaright)
	 ("M-<left>" . org-metaleft)
	 ("M-<down>" . org-metadown)
	 ; Chromebook
	 ("<next>" . org-metadown)
	 ("M-<up>" . org-metaup)
	 ; Chromebook
	 ("<prior>"   . org-metaup)
	 ("C-a" . org-beginning-of-line)
	 ("C-k" . org-kill-line)
	 ("C-c d" . org-deadline)
	 ("C-c k" . outline-show-branches)
	 ("C-c q" . org-set-tags-command)
	 ("C-c r" . org-reveal)
	 ("C-c s" . org-schedule)
	 ("C-c t" . org-todo)
	 ("C-c w" . org-refile)
	 ("C-x RET" . org-open-at-point))
	 :custom
	 (org-cycle-global-at-bob t))
#+END_SRC

** Configure Dired Mode

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package dired
    :bind (:map dired-mode-map
    ("C-p" . dired-previous-line)
    ("C-n" . dired-next-line)
    ("RET" . dired-find-file)))
#+END_SRC

** Configure Org Agenda

#+BEGIN_SRC emacs-lisp :tangle init.el

  (use-package org-agenda
    :bind (:map org-agenda-mode-map
    ("C-n" . org-agenda-next-line)
    ("C-p" . org-agenda-previous-line)
    ("TAB" . org-agenda-goto)
    ("g" . org-agenda-redo-all)
    ("t" . org-agenda-todo)
    ("u" . org-agenda-bulk-unmark)
    ("T" . org-agenda-show-tags))
    :config
    (setq org-agenda-span 'day)
    ;; Allow for very old scheduled items for catch-up behavior.
    (setq org-scheduled-past-days 99999)
    ;; Use hl-line mode in org-agenda for visibilitiy
    (add-hook 'org-agenda-mode-hook 'hl-line-mode))
#+END_SRC

** Configure hexl Mode

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package hexl
      :bind (:map hexl-mode
      ("C-v" . hexl-scroll-up)
      ("M-v" . hexl-scroll-down)))
#+END_SRC

** Configure Info Mode

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package info
    :bind (:map Info-mode-map
    ("SPC" . Info-scroll-up)))
#+END_SRC

** Configure Emacs Lisp

#+BEGIN_SRC emacs-lisp :tangle init.el

  (add-to-list 'auto-mode-alist '("\\.el\\'" . emacs-lisp-mode))
  (global-dash-fontify-mode)
  (with-eval-after-load 'info-look
    (dash-register-info-lookup))
  (bind-keys :map global-map
	     ("C-x C-e" . eval-last-sexp))

#+END_SRC

** Manage Environment for Called Commands

***** Shell Supplier

The evaluation itself will be performed through a shell command which
is defined here, defaulting to the Emacs standard.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defcustom ^-env-shell-supplier
    (lambda () shell-file-name)
    "Define the function which will return the shell to invoke
     along with any additional arguments."
    :type 'function
    :group '^-env)
#+END_SRC

***** Shell Login Argument Supplier

The shell command may also require some additional arguments to make
sure that it is executed using the login profile.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defcustom ^-env-shell-login-arg-supplier
    (lambda () '("-l" "-i"))
    "Define the function which will return arguments that when
     passed to the shell will operate in login mode."
    :type 'function
    :group '^-env)
#+END_SRC

***** Printf Command Supplier

As previously mentioned this will expect to be evaluated using some
form of printf...how practically extensible this is given the current
logic seems unclear - likely most of these functions would be better
off as being passed the argument they're expanding but all of that
feels like premature generalization and right now the goal is just to
define some of the magic values.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defcustom ^-env-printf-supplier
    (lambda () "printf")
    "Define the function which will return the printf command
     to be invoked by the shell."
    :type 'function
    :group '^-env)
#+END_SRC

**** Support Invoking the Commands

There's likely some better constructs for this floating around
somewhere, but for now I'll start with what was inherited.

***** Warn On Slow Evaluation

Warning on a slow call is carried forward from exec-from-shell...I'm
not entirely sure of its value given that there's no timeout behavior
and the execution is not typically done repeatedly.  I'd conjecture
that maybe this is useful as such slow executions could produce
undesirably slow Emacs start times. In any case it seems worth keeping
around for the time being.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defcustom ^-env-warn-evaluation-duration-millis-supplier
    (lambda () 500)
    "Print a warning if evaluation duration exceeds this number of milliseconds."
    :type 'function
    :group '^-env)
#+END_SRC

***** Support Timed Evaluation

****** TODO Replace with ~with-delayed-message~

There's nothing particularly specialized about timing a call so this
will be implemented through providing a first class function which
takes a curried handler to which the time will be passed and can then
be passed any body as a thunk which will be evaluated and timed.
This would almost certainly be more idiomatically a macro in Emacs
lisp but I tend to avoid that (which will be covered separately at
some point).

The implementation is typical timer behavior of tracking start time
and then reporting the difference between the start and end times (in
this case passing it to the handler. A general note (not specific to
this code or language) is that it is often desirable to consistently
report the time and therefore any calls that return through alternate
paths (such as exceptions) should also be tracked (and preferably
annotated accordingly). This is optimistically ignored for this code
(and I'd typically prefer Either semantics over exceptions which makes
that issue simpler to reason about) but that scenario may need further
attention with this code.

****** Millisecond Duration

The duration will be passed in milliseconds as that's what's inherited
from the original logic. This also generally seems to be the most
common unit for timing application code - it is appropriate for
relatively slow actions like invoking another process and faster
actions can be timed in aggregates which can help smooth out the many
things can skew sub-millisecond timings.

This provides a basic implementation to calculate such a duration
from two timestamps using Emacs functionality. There may be a
date/time library floating around that could replace this later.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-temporal-diff-millis (start end)
    (thread-last start
		(time-subtract end)
		float-time
		(* 1000.0)))
#+END_SRC

****** Implement Timer

This function body is a fairly straightforward higher-order
function. Currently the handler will be invoked with ~funcall~ (which
should be modified later).

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-timed (handler)
    "Produce a function that will invoke thunks and return their value
     while also passing the execution duration to <handler>."
    (lambda (thunk)
      (let* ((start-time (current-time))
	     (result (funcall thunk))
	     (duration (^-temporal-diff-millis start-time (current-time))))
	(funcall handler duration)
	result)))
#+END_SRC

****** Wire Warning

The specific handler for the duration warning needs to be configured
to be plugged into the general timer. This will be provided by a
closure over the setting which returns an appropriate handler.

**** Transplants

The environment variables that should be carried across profiles will
be called "transplants".

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defcustom ^-env-variable-transplants-supplier
    (lambda '("MANPATH"))
    "List of environment variables which will be transplanted on initialization."
    :group '^-env)
#+END_SRC

** Structurizr Mode

The details of some of these should be covered. Why does
font-lock-defaults require a nested list?

For now there is no hook defined since it wouldn't be used
(although it is likely to be standard).

#+BEGIN_SRC emacs-lisp :tangle init.el
  (define-derived-mode structurizr-mode fundamental-mode "Structurizr"
    "Major mode for editing Structurizr dsl"
    (set-syntax-table structurizr-mode-syntax-table)
    (make-local-variable 'structurizr-indent-offset)
    (set (make-local-variable 'indent-line-function) 'structurizr-indent-line)
    (setq font-lock-defaults (list (funcall structurizr-font-lock-default-collector))))
#+END_SRC

*** Font Lock

The definitions below are borrowed from the original mode, this should
tied back more directly to the DSL reference with any resulting
adjustment to naming or membership.

**** Words for Face

The original code also defined and then operated on values whereas
this will attempt to make more use of in-place definitions with
supporting functions as warranted.

This seems like something that likely already exists but to start this
will make use of what was originally in place but wrap it up in a
function for more direct use.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-words-for-face (face words)
    "Return a pair of a regexp matching <words> and the provided <face>."
    (cons (regexp-opt words 'words) face))
#+END_SRC

**** List Collector

There is likely something readily available somewhere else that does
this. When defining keywords in this file it is nice to allow each
block to be self-contained so that it can be evaluated easily, but
when collecting all lists that invites some possibly fragile
mutability. To make this slightly cleaner, at least according to my
tastes, we'll use an accumulator closure over the list that appends an
argument if provided and returns the contents if no argument is provided.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-list-collector ()
    "Produce a list collector."
    (let ((l nil))
      (lambda (&optional arg)
	(if arg (push arg l) l))))
#+END_SRC

**** Collect Categories of Known Words

Each block will push onto the list to keep the blocks self-contained.

There's a note around ordering being significant...ideally this can be
avoided if it is substantiated but otherwise it should be very clearly
laid out or ideally encoded within the logic.

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq structurizr-font-lock-default-collector (^-list-collector))
#+END_SRC

***** Keywords

#+BEGIN_SRC emacs-lisp :tangle init.el
  (funcall structurizr-font-lock-default-collector
	   (^-words-for-face
	    'font-lock-keyword-face
	    '(
	      "enterprise"
	      "model"
	      "views"
	      "workspace"
	      )))
#+END_SRC

***** Types

#+BEGIN_SRC emacs-lisp :tangle init.el
  (funcall structurizr-font-lock-default-collector
	   (^-words-for-face
	    'font-lock-type-face
	    '(
	      "branding"
	      "component"
	      "container"
	      "containerInstance"
	      "deployment"
	      "deploymentEnvironment"
	      "deploymentGroup"
	      "deploymentNode"
	      "dynamic"
	      "element"
	      "filtered"
	      "group"
	      "infrastructureNode"
	      "person"
	      "perspectives"
	      "properties"
	      "relationship"
	      "softwareSystem"
	      "softwareSystemInstance"
	      "styles"
	      "systemContext"
	      "systemLandscape"
	      "themes"
	      )))
#+END_SRC

***** Relationship

#+BEGIN_SRC emacs-lisp :tangle init.el
  (funcall structurizr-font-lock-default-collector
	   (^-words-for-face
	    'font-lock-function-name-face
	    '("->")))
#+END_SRC

***** Properties

#+BEGIN_SRC emacs-lisp :tangle init.el
  (funcall structurizr-font-lock-default-collector
	   (^-words-for-face
	    'font-lock-variable-name-face
	    '(
	      "autoLayout"
	      "background"
	      "border"
	      "color"
	      "colour"
	      "dashed"
	      "description"
	      "exclude"
	      "fontSize"
	      "height"
	      "icon"
	      "include"
	      "metadata"
	      "opacity"
	      "position"
	      "routing"
	      "shape"
	      "stroke"
	      "tags"
	      "technology"
	      "thickness"
	      "title"
	      "url"
	      "width")))
#+END_SRC

*** Indentation
**** Configure Offset

#+BEGIN_SRC emacs-lisp :tangle init.el

(defvar structurizr-indent-offset 4
  "Define the indentation offset for `structurizr-mode'.
Lines will be indented this offset multiplied by the detected level.
Currently only spaces are supported.")

#+END_SRC

**** Determine Indentation Level

The basic algorithm here will start from what was defined upstream.
This will be broken up a bit and in the future any other standard
algorithms will be explored.

This currently adjusts the formatting after a newline rather than
inserting the character itself so something more electric may be better.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun structurizr-indent-line ()
    "Indent current line as Structurizr dsl."
    (interactive)
    (let* ((initial-level (^-opener-count-to-top "{"))
	   (closers (^-closers-on-line "}"))
	   (level (max 0 (- initial-level closers))))
      (indent-line-to (* level structurizr-indent-offset))))

#+END_SRC

***** Opener Count to Top

The current approach involves ascending lists until an ignored error
is encountered, and then reporting the count of the number of a
particular opener that was encountered.

This feels like it should be simpler in some way or another. This
level should potentially be readily available and the ascension
behavior should be tied to the relevant grammar which would obviate
the need for the additional check. At the moment I don't know what
options are available and unused versus those that would need further
support so I'll circle back to this over time (especially as other
modes are pulled in).

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-opener-count-to-top (opener)
    "Ascend through levels and count the number of <opener>s seen."
    (let ((level 0))
      (save-excursion
	(beginning-of-line)
	(condition-case nil
	    (while t
	      (backward-up-list 1)
	      (when (looking-at opener)
		(setq level (+ level 1))))
	  (error nil)))
      level))
#+END_SRC

***** Closer Count

The current logic only decrements one if the first character is a
closer. This may be nicer to just count all instances but that feels
like a taste based on the resulting behavior. In any case it should
likely support either.

In the current form this will either return 0 or 1.

There was also a separate test initially which seemed to look to
prevent over-outdenting which can be addressed by a ramp function on
outside use.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-closers-on-line (closer)
    (save-excursion
      (back-to-indentation)
      (if (looking-at closer) 1 0)))
#+END_SRC

*** Syntax Table

The standard syntax table function ~newentry~ value is bit arcane so
I'm going to try to define some more expressive functions to produce
the values (and likely find something that exists elsewhere).

This can be generalized a bit as needed by producing functions which
produce the first character but in the short term the only interesting
one I need is for punctuation so that will be written as
specialized. The underlying logic can then be a function which accepts
named flags as keywords each of which will map to the underlying terse flag.

Initially I'll use a fairly clunky ~cond~ block though there is almost
certainly something cleaner. This could be cleaned up through partial
application but I'd imagine there's some better pattern matching stuff
I need to stumble upon.

This should all be significantly cleaned up into a nicer DSL (or
ideally an existing one found) but right now I'm starting with the
basics. In particular the relationships between some of the flags
should be modeled in that DSL whereas the naive approach allows for
seemingly invalid combinations. These should also operate on a closure
over a comment table.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun ^-syntax-table-punctuation (&rest flags)
    (apply #'concat (cons ". "
	    (mapcar (lambda (flag)
		      (cond
		       ((eq flag :start-2char-comment-open) "1")
		       ((eq flag :end-2char-comment-open) "2")
		       ((eq flag :start-2char-comment-close) "3")
		       ((eq flag :end-2char-comment-close) "4")
		       ((eq flag :for-comment-sequence-b) "b")
		      (t (error "Unrecognized flag" flag))))
		    flags))))
  (defun ^-syntax-table-comment-ender () ">")

#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el

(setq structurizr-mode-syntax-table
  (let ((syntax-table (make-syntax-table)))
    (modify-syntax-entry
      ?/
      (^-syntax-table-punctuation
        :start-2char-comment-open
	:end-2char-comment-open
	:end-2char-comment-close)
      syntax-table)
    (modify-syntax-entry
      ?*
      (^-syntax-table-punctuation
        :end-2char-comment-open
	:start-2char-comment-close
	:for-comment-sequence-b))
    (modify-syntax-entry ?\n (^-syntax-table-comment-ender) syntax-table)
    syntax-table))

#+END_SRC

*** Associate with Extension

~dsl~ is certainly not unambiguously Strucutrizr files,
but it's the only association I'm currently expecting.

#+BEGIN_SRC emacs-lisp :tangle init.el

(add-to-list 'auto-mode-alist '("\\.dsl\\'" . structurizr-mode))

#+END_SRC

** Programming Support

This is currently copied forward but past configurations but not
revisited. It looks as though this is the beginning of seeking to
support code collapsing.

#+BEGIN_SRC emacs-lisp :tangle init.el

  (add-hook 'prog-mode-hook hs-minor-mode)
  (bind-keys :map prog-mode-map
	     ("C-M-_". hs-toggle-hiding))

#+END_SRC

*** C

#+BEGIN_SRC emacs-lisp :tangle init.el

  (add-to-list 'auto-mode-alist '("\\.c\\'" . c-mode))

#+END_SRC

** Configure Lilypond

This is the very beginning of support for Lilypond mode, which I think
I started to copy from the Lilypond source code years ago. This is
unlikely to provide any valuable in its current form and so will
either be built upon further later or removed.

#+BEGIN_SRC emacs-lisp :tangle init.el

    (defvar LilyPond-mode-map ()
      "Keymap used in `LilyPond-mode' buffers.")

    (defun LilyPond-mode ()
      "Major mode for editing LilyPond music files.

  This mode knows about LilyPond keywords and line comments, not abou
  indentation or block comments.  It features easy compilation, error
  finding and viewing of a LilyPond source buffer or region.

  COMMANDS
  \\{LilyPond-mode-map}
  VARIABLES

  LilyPond-command-alist\t\talist from name to command"
      (interactive)
      ;; set up local variables
      (kill-all-local-variables))

  (add-to-list 'auto-mode-alist '("\\.ly$" . LilyPond-mode))
  (add-to-list 'auto-mode-alist '("\\.ily$" . LilyPond-mode))

#+END_SRC

** Configure Gnus

I'm currently using Gnus to read my mail but have not yet dug into it
again - this like many others reflect inherited previous configuration options.

#+BEGIN_SRC emacs-lisp :tangle init.el

  ;; This should be cleaned up a bit but was just implemented in the most
  ;; obvious way for now.
  (defun gnus-group-read-50 ()
    (interactive)
    (gnus-group-read-group 50))

  (use-package gnus
    :bind (:map gnus-group-mode-map
	   ("M-g" . gnus-group-get-new-news-this-group)
	   ("M-<down>" . gnus-group-read-50)
	   :map gnus-summary-mode-map
	   ("M-<down>" . gnus-summary-next-page)
	   ("C-c m" . gnus-summary-move-article))
    :custom (setq gnus-select-method
		  '(nnimap "imap.gmail.com")
		  (nnimap-server-port "imaps")))

#+END_SRC

** Configure EWW

On Linux I may explore EAF but for now I'll be using EWW since EAF is
currently Linux only and isn't working particularly well as configured
on my Sway installation.

#+BEGIN_SRC emacs-lisp :tangle init.el

  (use-package eww
    :bind (:map eww-mode-map
		("C-c w" . eww-copy-page-url)))
  (setq browse-url-browser-function 'eww-browse-url)

#+END_SRC

** Queue
*** TODO Find or define more expressive mode-alist registration

#  LocalWords:  Minibuffer Dired hexl Structutrizr Structurizr EWW

